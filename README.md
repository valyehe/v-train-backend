# 仿12306笔记

## 项目描述

本项目是一个仿照12306购票系统的在线购票系统，旨在提供用户方便快捷的购票体验。通过该系统，用户可以实现查询车次、选择座位、购买车票等功能。

## 技术选型

前端：Vue3+Ant Design Vue
后端：Springboot3+Spring Cloud Alibaba+Mybatis+Redis+RocketMQ+Seata+JWT+MySQL

## 项目收获

### 项目亮点

- 使用三端分离，会员端、控台端、服务端，便于开发和维护，同时将界面与功能逻辑分开，易于分配不同的资源。
- 使用微服务生态组件：注册中心、配置中心、网关、限流降级、分布式事务、服务调用，保障服务高可用。
- 将系统功能拆分成多个微服务应用，实现服务间低耦合，服务内功能高内聚。
- 使用Redis、MQ等中间件，提升系统性能，保障服务高性能响应。
- 使用分布式锁解决超卖问题，使用Seata的AT模式解决分布式事务问题。
- 对并发请求做削峰处理，解决吞吐量问题，在项目中使用令牌大闸进行防刷和限流，使用RocketMQ进行削峰解决吞吐量问题，经过改造后，吞吐量和并发量都提高了25倍左右。

### 高并发（秒杀）设计维度

前端

- 静态资源CDN
- 页面静态化
- 倒计时/loading展示
- 验证码进行削峰处理

后端

- 微服务-服务拆分
- 负载均衡
- 限流降级
- 缓存
- 令牌
- 异步处理

数据库

- 分库：业务分库，读写分离
- 分表：横向分表（地区/时间），纵向分表（列）
- 冗余设计，反范式，空间换时间
- 分布式数据库

其他

- 分时段秒杀
- 弹性扩容
- 候补+排队

### springboot3，jdk17新特性

JIT(实时编译) java跨平台的基础

- 问题：在高并发下重启热点应用出现业务超时，几分钟恢复正常的情况
- 原因：启动后有大量请求，导致多个类触发JIT导致超时，导致CPU升高，出现超时
- 解决方案：预热（让程序自动运行热点代码），流量控制（启动时小流量，运行几分钟正常）

AOT（预编译）无法跨平台

- 解决方案：使用GraaIVM代替JDK实现

### 缓存使用

MyBatis缓存：

- 序列化：类传输的场景
- 一级缓存：减少重复的数据库查询 (默认是Session，可以修改为Statement关闭一级缓存)
- 二级缓存：（mapper中使用cache标签），增删改查会失效，多节点缓存不一致问题

内置缓存：

- 分页后依然击中缓存：hash和equals方法未添加分页参数
- 多节点缓存不一致问题
- @CachePut强制缓存，@Cachealbe不会删除缓存

redis缓存：

- 解决访问速度
- 解决多节点缓存不一致问题
- 缓存击穿：定时任务，增加分布式锁
- 缓存穿透：返回空列表，增加分布式锁
- 缓存雪崩：缓存过期日期

缓存在高并发场景中的生产问题分享：

- 场景:每天的会员数很多，百万级别，但每个会员一天只会有几次请求，一个会员信息在同一次请求中，会被用到多次，且会员信息较大
  问题:多次调用查询会员方法，组装信息多，多次访问数据库
- 解决:使用本地缓存，1分钟有效
- 问题:fullgc(stop the world)频繁，导致短时间内大量请求失败
- 解决:去掉本地缓存，使用线程本地变量

### Seata解决分布式事务问题

- AT模式，默认，简单，需要增加undo_log表，生成反向SQL，性能高回滚后，原来没数据的，现在还是没数据
- TCC模式，try confirm/cancel，三个阶段的代码都得自己实现，Seata只负责调度对业务代码侵入性较强，必要时可能还要修改数据库
- SAGA模式，长事务解决方案，需要程序员自己编写两阶段代码（AT模式不需要写第二阶段)基于状态机来实现的，需要一个JSON文件，可异步执行
- XA模式，XA协议是由X/Open组织提出的分布式事务处理规范，基于数据库的XA协议来实现2PC又称为XA方案，适用于强一致性的场景，比如金融、银行等

### 分布式锁解决超卖问题

- synchronized：性能下降， 只能解决单机超卖
- Redis分布式锁：setnx，问题：其他线程删除正常线程
- Redission: 看门狗机制（避免超时），问题：redis宕机
- Redis红锁：奇数个节点，线程拿到一半以上算拿到锁，解决宕机问题，顺序获取节点避免拿到部分节点的问题，获取锁的时间超过设置的时间避免节点慢获取时被释放，宕机后不能马上重启或者尝试获取所有节点解决锁互斥

### Sentinel限流熔断降级

- 限流算法：静态窗口，动态窗口，漏桶限流，令牌桶，令牌大闸（判断库存，防刷）

### （令牌大闸）防刷+限流设计方案

- 增加令牌表用以维护令牌信息
- 初始化车次信息时初始化令牌
- 增加校验令牌的操作，防刷：获取分布式锁（key），通过key判断防刷，查数据，-1操作，不释放锁，在购票前校验
- 使用缓存加速令牌（获取后刷新缓存，每获取5个令牌更新一次数据库）
- 增加验证码分散请求，削峰并防刷（前端生成唯一token，每次不能一样，用于验证码的生成和验证），可优化增加两层验证码

### RocketMQ进行削峰解决吞吐量

将购票流程分为两部分，请求进来后，先保存订单信息，再发MQ等待出票

增加排队功能：

- 对某一个订单开始出票时修改状态为处理中，避免重复提交，
- 某一个订单余票不足时，继续售卖下一个订单
- MQ消费里，没抢到锁的，表示有其他消费线程正在出票，不做任何处理

增加轮询购票结果功能：

确认订单后，显示：处理中，返回确认订单id，增加相应接口，实现功能

### 压力测试

概念：

- 并发量:指在同一时间点内，系统中同时处理的用户请求数
- 响应时间:指系统处理一个请求所需的时间。
- 吞吐量:是指系统在给定时间内处理的业务请求数量
- QPS (Queries Per Second)，表示系统每秒钟处理的请求数量
- TPS (Transactions Per Second)，表示系统每秒钟完成的事务数量

最高并发数探测方法:

- 增加线程数，直到出现异常
- 增加线程数，直到平均响应时间超过预期的值(依项目而定，比如买票最多让用户等待2秒)

结论:

- 经过改造后，吞吐量和并发量都提高了25倍左右，即整体性能提升了25倍左右